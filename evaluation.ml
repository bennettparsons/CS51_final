(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
    val exp_of_val : value -> expr
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

  (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let rec lookup (env: env) (varname: varid) : value =
      match env with
      | [] -> raise (EvalError ("Unbound value " ^ varname))
      | (v, loc)::tl -> if v = varname then !loc else lookup tl varname ;;

    (* Returns a new environment just like env except that it maps the
     * variable varid to loc *)
    let rec extend (env: env) (varname: varid) (loc: value ref) : env =
      match env with
      | [] -> (varname, loc)::env
      | (v, loc0)::tl -> if v = varname then  (v,loc)::tl
                         else (v, loc0)::(extend tl varname loc) ;;

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      List.fold_left
        (fun acc (v, loc) -> 
          acc ^ (v ^ "==>") ^ (value_to_string !loc) ^ "  ") "" env

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val exp -> "Val: " ^ (exp_to_string exp)
      | Closure (exp, env) -> 
        "Closure: (" ^ (exp_to_string exp) ^ 
          (if printenvp then " in env: " ^ "(" ^ (env_to_string env) ^ "))" 
          else ")") ;;

    (* extracts the expression from a value *)
    let exp_of_val (value : value) : expr =
    match value with
    | Val exp -> exp
    | Closure (exp, _) -> exp

  end
;;

open Env ;;

(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)  
let eval_t exp _env = Val exp ;;

let eval_s exp _env = 
  let rec eval exp = 
    match exp with
    | Var v -> raise (EvalError ("Unbound value " ^ v))
    | Num i -> exp
    | Bool b -> exp
    | Unop (o, exp) ->
    (* Unop helper *)
      let unop o exp = 
        match eval exp with
        | Num i -> 
          if o = "~" then Num ((~-) i)
          else raise (EvalError "An expression was expedted of type Num")
        | Bool b ->
          if o = "not" then Bool (not b)
          else raise (EvalError "An expression was expedted of type Bool")
        | _ -> raise (EvalError "Unop not supported") in
      (match o with
      | "~" -> unop "~" exp
      | "not" -> unop "not" exp
      | _ -> raise (EvalError "Unop not supported"))
    | Binop (o, exp1, exp2) ->
      (* Binop helpers *)
      let binop_num o exp1 exp2 = 
        match eval exp1, eval exp2 with
          | Num x, Num y -> Num ((o) x y)
          | _ -> raise (EvalError "An expression was expected of type Num") in
      let binop_bool o exp1 exp2 =
        (* necessary to circumvent ocaml type checking *) 
        let int_of_bool b =
          if b then 1 else 0 in
        match eval exp1, eval exp2 with
          | Num x, Num y -> Bool ((o) x y)
          | Bool b1, Bool b2 -> 
            Bool ((o) (int_of_bool b1) (int_of_bool b2))
          | _ -> raise (EvalError 
            "This operator can only be applied to two Nums or two Bools") in
      (match o with
      | "+" -> binop_num ( + ) exp1 exp2
      | "-" -> binop_num ( - ) exp1 exp2
      | "*" -> binop_num ( * ) exp1 exp2
      | "/" -> binop_num ( / ) exp1 exp2
      | "=" -> binop_bool ( = ) exp1 exp2
      | "<" -> binop_bool ( < ) exp1 exp2
      | ">" -> binop_bool ( > ) exp1 exp2
      | "<>" -> binop_bool ( <> ) exp1 exp2
      | _ -> raise (EvalError "Binop not supported"))
    | Conditional (if_exp, then_exp, else_exp) ->
      (match eval if_exp with
      | Bool (true) -> eval then_exp
      | Bool (false) -> eval else_exp
      | _ -> raise (EvalError "An expression was expected of type Bool"))
    | Fun (_, _) -> exp
    | Let (v, def_exp, in_exp) -> 
      eval (subst v (eval def_exp) in_exp)
    | Letrec (v, def_exp, in_exp) -> 
      let new_exp = eval (subst v (Letrec (v, def_exp, Var v)) def_exp) in
      eval (subst v new_exp in_exp)
    | Raise -> raise EvalException
    | Unassigned -> raise EvalException
    | App (app_exp, arg_exp) ->
      match eval app_exp with
      | Fun (v, exp) -> eval (subst v (eval arg_exp) exp)
      | _ -> raise (EvalError "bad redex") in
  Val (eval exp) ;;

(* common code for eval_d, eval_d_ext and eval_l;
 * flag = true => dynamic scoping 
 * flag = flase => lexical scoping 
 * ext = true => togles extension of dynamic scoping *)
let eval_all exp env flag ext = 
  let flag = ref flag in
  let rec eval exp env =
    match exp with
    | Var v -> 
      (* we eval the lookup in dynamic scoping  *)
      if !flag then eval (exp_of_val (lookup env v)) env 
      else lookup env v, env
    | Num i -> Val exp, env
    | Bool b -> Val exp, env
    | Unop (o, exp) ->
    (* Unop helper *)
      let unop o exp = 
        match eval exp env with
        | Val (Num i), _ -> 
          if o = "~" then Val (Num ((~-) i)), env
          else raise (EvalError "An expression was expedted of type Num")
        | Val (Bool b), _ ->
          if o = "not" then Val (Bool (not b)), env
          else raise (EvalError "An expression was expedted of type Bool")
        | _ -> raise (EvalError "Unop not supported") in
      (match o with
      | "~" -> unop "~" exp
      | "not" -> unop "not" exp
      | _ -> raise (EvalError "Unop not supported"))
    | Binop (o, exp1, exp2) ->
      (* Binop helpers *)
      let binop_num o exp1 exp2 = 
        match eval exp1 env, eval exp2 env with
          | (Val (Num x), _) , (Val (Num y), _) -> Val (Num ((o) x y)), env
          | _ -> raise (EvalError "An expression was expected of type Num") in
      let binop_bool o exp1 exp2 =
        (* trickery to evaluate the bool comparisons *) 
        let int_of_bool b =
          if b then 1 else 0 in
        match eval exp1 env, eval exp2 env with
          | (Val (Num x), _) , (Val (Num y), _) -> Val (Bool ((o) x y)), env
          | (Val (Bool b1), _) , (Val (Bool b2), _) -> 
            Val (Bool ((o) (int_of_bool b1) (int_of_bool b2))), env
          | _ -> raise (EvalError 
            "This operator can only be applied to two Nums or two Bools") in
      (match o with
      | "+" -> binop_num ( + ) exp1 exp2
      | "-" -> binop_num ( - ) exp1 exp2
      | "*" -> binop_num ( * ) exp1 exp2
      | "/" -> binop_num ( / ) exp1 exp2
      | "=" -> binop_bool ( = ) exp1 exp2
      | "<" -> binop_bool ( < ) exp1 exp2
      | ">" -> binop_bool ( > ) exp1 exp2
      | "<>" -> binop_bool ( <> ) exp1 exp2
      | _ -> raise (EvalError "Binop not supported"))
    | Conditional (if_exp, then_exp, else_exp) ->
      (match eval if_exp env with
      | Val (Bool (true)), _ -> eval then_exp env
      | Val (Bool (false)), _ -> eval else_exp env
      | _ -> raise (EvalError "An expression was expected of type Bool"))
    (* close in lexical scoping *)
    | Fun (_, _) -> if !flag then Val (exp), env else close exp env, env
    | Let (v, def_exp, in_exp) -> 
      eval in_exp (extend env v (ref (fst (eval def_exp env))))
    | Letrec (v, def_exp, in_exp) ->
      flag := true;
      eval in_exp (extend env v (ref (fst (eval def_exp 
                    (extend env v (ref (Val Unassigned)))))))
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError 
      "This kind of expression is not allowed as right-hand side of `let rec'")
    | App (app_exp, arg_exp) ->
      match eval app_exp env with
      (* returned in lexical scoping *)
      | Closure (Fun (v, exp1), closed_env), _ ->
        let final_env = (extend closed_env v (ref (fst (eval arg_exp env)))) in
        eval exp1 final_env
      (* returned in dynamic scoping *)
      | Val (Fun (v, exp1)), env0 -> 
        let env_active = if ext then env0 else env in
        let extended_env = 
          (extend env_active v (ref (fst (eval arg_exp env_active)))) in
        eval exp1 extended_env
      | _ -> raise (EvalError "bad redex") in
  fst (eval exp env) ;;

let eval_d exp env =  (eval_all exp env true false) ;;

let eval_d_ext exp env = (eval_all exp env true true) ;;

let eval_l exp env = (eval_all exp env false true) ;;

let evaluate = eval_d ;;


